<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title> ë¡œì»¬ 2ì¸ìš© ê²Œì„ (40 ìŠ¤í‚¬)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;700&display=swap');
        body {
            font-family: 'Noto Sans KR', sans-serif;
            background-color: #0f172a; /* Slate 900 */
        }
        .hp-bar-fill, .energy-bar-fill {
            transition: width 0.5s ease-in-out;
        }
        .player-card {
            background-color: #1e293b; /* Slate 800 */
            border: 3px solid transparent;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
        }
        .current-turn-glow {
            border-color: #3b82f6; /* Blue 500 */
            box-shadow: 0 0 20px rgba(59, 130, 246, 0.5);
        }
        .combat-log {
            height: 150px;
            overflow-y: auto;
            background-color: #020617; /* Slate 950 */
        }
        .skill-button {
            transition: all 0.1s;
            transform-origin: center;
        }
        .skill-button:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 4px 10px rgba(59, 130, 246, 0.4);
        }
        .skill-button:disabled {
            cursor: not-allowed;
            opacity: 0.5;
        }
        .selection-card {
            min-height: 100px;
        }
        .skill-select-item {
            cursor: pointer;
            transition: all 0.2s;
        }
        .skill-select-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        }
    </style>
</head>
<body class="p-4 sm:p-8 min-h-screen flex flex-col items-center justify-center">

    <!-- Header -->
    <header class="text-center mb-8">
        <h1 class="text-4xl font-extrabold text-blue-400 mb-2">ğŸ”¥ í„´ì œ ìŠ¤í‚¬ ë°°í‹€ ğŸ”¥</h1>
        <p id="game-status-text" class="text-xl font-bold text-gray-200 transition duration-500"></p>
    </header>

    <main class="w-full max-w-4xl space-y-8">
        
        <!-- ============================================== -->
        <!-- 1. ìŠ¤í‚¬ ì„ íƒ í™”ë©´ (SETUP SCREEN) -->
        <!-- ============================================== -->
        <div id="setup-screen">
            <h2 class="text-3xl font-bold text-yellow-400 text-center mb-6">ìŠ¤í‚¬ ì„ íƒ (6ê°œ ì„ íƒ í•„ìˆ˜)</h2>

            <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
                <!-- Player 1 Selection -->
                <div class="bg-slate-700 p-4 rounded-xl shadow-lg selection-card">
                    <h3 class="text-xl font-bold text-blue-300 mb-2">ğŸ§‘â€ğŸš€ í”Œë ˆì´ì–´ 1</h3>
                    <p id="p1-selection-count" class="text-sm text-gray-300 mb-4">ì„ íƒí•œ ìŠ¤í‚¬: 0 / 6</p>
                    <div id="p1-selected-skills" class="flex flex-wrap gap-2 min-h-[50px] border border-blue-400 p-2 rounded-lg bg-slate-800">
                        <!-- P1 ì„ íƒëœ ìŠ¤í‚¬ ëª©ë¡ -->
                    </div>
                </div>

                <!-- Player 2 Selection -->
                <div class="bg-slate-700 p-4 rounded-xl shadow-lg selection-card">
                    <h3 class="text-xl font-bold text-red-300 mb-2 text-right">í”Œë ˆì´ì–´ 2 ğŸ¦¹</h3>
                    <p id="p2-selection-count" class="text-sm text-gray-300 mb-4 text-right">ì„ íƒí•œ ìŠ¤í‚¬: 0 / 6</p>
                    <div id="p2-selected-skills" class="flex flex-wrap gap-2 justify-end min-h-[50px] border border-red-400 p-2 rounded-lg bg-slate-800">
                        <!-- P2 ì„ íƒëœ ìŠ¤í‚¬ ëª©ë¡ -->
                    </div>
                </div>
            </div>

            <!-- Start Button -->
            <div class="text-center mb-8">
                <button id="start-battle-btn" onclick="startBattle()" class="w-full max-w-sm py-4 bg-green-600 text-white text-xl font-bold rounded-lg transition duration-300 hover:bg-green-700 disabled:bg-gray-500 shadow-xl" disabled>
                    ì „íˆ¬ ì‹œì‘
                </button>
            </div>

            <!-- Master Skill List -->
            <h3 class="text-2xl font-bold text-gray-200 mb-4 text-center">ì „ì²´ ìŠ¤í‚¬ ëª©ë¡ (40ê°œ)</h3>
            <p class="text-sm text-gray-400 text-center mb-4">ê° í”Œë ˆì´ì–´ì˜ ì´ë¦„(P1/P2)ì„ í´ë¦­í•˜ì—¬ í•´ë‹¹ í”Œë ˆì´ì–´ì˜ ìŠ¤í‚¬ì„ ì„ íƒ/ì·¨ì†Œí•˜ì„¸ìš”.</p>
            <div id="master-skill-list" class="grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-4 gap-3 p-4 bg-slate-800/70 rounded-xl max-h-[500px] overflow-y-auto">
                <!-- Master Skill Buttons will be populated here -->
            </div>
        </div>


        <!-- ============================================== -->
        <!-- 2. ì „íˆ¬ í™”ë©´ (BATTLE SCREEN) -->
        <!-- ============================================== -->
        <div id="battle-screen" class="hidden space-y-8">
            
            <!-- Player Cards -->
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">

                <!-- Player 1 Card -->
                <div id="player1-card" class="player-card p-4 rounded-xl text-white shadow-lg transition duration-300">
                    <h2 class="text-2xl font-bold mb-3 text-blue-300">ğŸ§‘â€ğŸš€ í”Œë ˆì´ì–´ 1</h2>
                    <!-- HP Bar -->
                    <div class="mb-2">
                        <p class="text-sm font-semibold mb-1">ì²´ë ¥ (HP): <span id="p1-hp-text">100 / 100</span></p>
                        <div class="w-full bg-red-800 rounded-full h-4">
                            <div id="p1-hp-bar" class="hp-bar-fill bg-red-500 h-4 rounded-full" style="width: 100%;"></div>
                        </div>
                    </div>
                    <!-- Energy Bar -->
                    <div class="mb-4">
                        <p class="text-sm font-semibold mb-1">ì—ë„ˆì§€ (E): <span id="p1-energy-text">50 / 50</span></p>
                        <div class="w-full bg-yellow-800 rounded-full h-3">
                            <div id="p1-energy-bar" class="energy-bar-fill bg-yellow-400 h-3 rounded-full" style="width: 100%;"></div>
                        </div>
                    </div>
                    <!-- Status Effects -->
                    <div class="text-xs text-gray-400">
                        ìƒíƒœ: <span id="p1-status">ì—†ìŒ</span>
                    </div>
                </div>

                <!-- Player 2 Card -->
                <div id="player2-card" class="player-card p-4 rounded-xl text-white shadow-lg transition duration-300">
                    <h2 class="text-2xl font-bold mb-3 text-red-300 text-right">í”Œë ˆì´ì–´ 2 ğŸ¦¹</h2>
                    <!-- HP Bar -->
                    <div class="mb-2">
                        <p class="text-sm font-semibold mb-1 text-right">ì²´ë ¥ (HP): <span id="p2-hp-text">100 / 100</span></p>
                        <div class="w-full bg-red-800 rounded-full h-4">
                            <div id="p2-hp-bar" class="hp-bar-fill bg-red-500 h-4 rounded-full" style="width: 100%;"></div>
                        </div>
                    </div>
                    <!-- Energy Bar -->
                    <div class="mb-4">
                        <p class="text-sm font-semibold mb-1 text-right">ì—ë„ˆì§€ (E): <span id="p2-energy-text">50 / 50</span></p>
                        <div class="w-full bg-yellow-800 rounded-full h-3">
                            <div id="p2-energy-bar" class="energy-bar-fill bg-yellow-400 h-3 rounded-full" style="width: 100%;"></div>
                        </div>
                    </div>
                    <!-- Status Effects -->
                    <div class="text-xs text-gray-400 text-right">
                        ìƒíƒœ: <span id="p2-status">ì—†ìŒ</span>
                    </div>
                </div>
            </div>
            
            <!-- Skill Buttons -->
            <div id="skill-buttons" class="grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-6 gap-3 p-4 bg-slate-800/70 rounded-xl">
                <!-- Skill buttons will be populated here by JavaScript -->
            </div>

            <!-- Combat Log -->
            <div class="combat-log p-4 rounded-xl text-sm text-gray-300 border border-gray-700">
                <p class="text-lg font-semibold text-blue-400 mb-2">ì „íˆ¬ ê¸°ë¡</p>
                <div id="log-output" class="space-y-1">
                    <p>[ì‹œìŠ¤í…œ] ê²Œì„ì´ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤. í”Œë ˆì´ì–´ 1ì˜ í„´ì…ë‹ˆë‹¤!</p>
                </div>
            </div>

            <!-- Reset Button -->
            <div class="text-center">
                <button onclick="showSetupScreen()" class="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg transition duration-300 shadow-lg">
                    ìŠ¤í‚¬ ì¬ì„ íƒ ë° ì¬ì‹œì‘
                </button>
            </div>
        </div>

        <!-- Game Over Modal -->
        <div id="game-over-modal" class="fixed inset-0 bg-black bg-opacity-80 hidden items-center justify-center p-4 z-50">
            <div class="bg-slate-700 p-8 rounded-xl shadow-2xl text-center max-w-sm w-full">
                <h2 id="winner-text" class="text-3xl font-extrabold mb-4 text-yellow-400">ìŠ¹ë¦¬!</h2>
                <p class="text-gray-200 mb-6">ì „íˆ¬ê°€ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.</p>
                <button onclick="hideModal(); showSetupScreen();" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition duration-300">
                    ìŠ¤í‚¬ ì¬ì„ íƒ
                </button>
            </div>
        </div>

    </main>

    <script>
        // Constants and Skill Definitions (40-Skill Framework)
        const MAX_HP = 100;
        const MAX_ENERGY = 50;
        const ENERGY_REGEN = 15;
        const MAX_SKILLS_PER_PLAYER = 6;
        const MAX_STATUS_STACKS = 3;

        // SKILLS ë°°ì—´ (40ê°œ)
        const SKILLS = [
            // ID 1-5: ê¸°ë³¸ ê³µê²© ë° ë°©ì–´
            { id: 1, name: 'ì•½í•œ ê³µê²©', type: 'attack', cost: 5, power: 15, target: 'enemy', effect: null, desc: 'ê°€ì¥ ê¸°ë³¸ì ì¸ ê³µê²©ì…ë‹ˆë‹¤.' },
            { id: 2, name: 'ì—ë„ˆì§€ ì¦í­', type: 'utility', cost: 0, power: ENERGY_REGEN + 5, target: 'self', effect: 'energy', desc: 'ìµœëŒ€ ì—ë„ˆì§€ëŸ‰ì„ ì˜êµ¬ì ìœ¼ë¡œ ì¦ê°€ì‹œí‚µë‹ˆë‹¤.' },
            { id: 3, name: 'ë‹¨ë‹¨í•œ ë°©ì–´', type: 'defend', cost: 10, power: 30, target: 'self', effect: 'defense', desc: 'ë‹¤ìŒ í„´ì— ë°›ëŠ” í”¼í•´ë¥¼ ê°ì†Œì‹œí‚µë‹ˆë‹¤. (ë°©ì–´ë ¥ +30)' },
            { id: 4, name: 'ê°•íƒ€', type: 'attack', cost: 15, power: 25, target: 'enemy', effect: null, desc: 'ê°•ë ¥í•œ ë¬¼ë¦¬ ê³µê²©ì…ë‹ˆë‹¤.' },
            { id: 5, name: 'ì¹˜ìœ ì˜ ë¹›', type: 'heal', cost: 20, power: 30, target: 'self', effect: null, desc: 'ìì‹ ì˜ ì²´ë ¥ì„ íšŒë³µí•©ë‹ˆë‹¤.' },

            // ID 6-10: ë””ë²„í”„ ë° CC
            { id: 6, name: 'ë… ë°”ë¥´ê¸°', type: 'debuff', cost: 10, power: 0, target: 'enemy', effect: 'poison', desc: 'ìƒëŒ€ì—ê²Œ ë…ì„ ë¶€ì—¬í•˜ì—¬ ë§¤ í„´ í”¼í•´ë¥¼ ì¤ë‹ˆë‹¤. (3í„´)' },
            { id: 7, name: 'ëŠë¦° ë°œê±¸ìŒ', type: 'debuff', cost: 15, power: 0, target: 'enemy', effect: 'slow', desc: 'ìƒëŒ€ë°©ì˜ ë‹¤ìŒ ê³µê²©ë ¥ì„ ì•½í™”ì‹œí‚µë‹ˆë‹¤. (ê³µê²©ë ¥ -15)' },
            { id: 8, name: 'ì¹¨ë¬µì˜ ì£¼ë¬¸', type: 'debuff', cost: 25, power: 0, target: 'enemy', effect: 'silence', desc: 'ë‹¤ìŒ í„´ì— ìƒëŒ€ë°©ì˜ ì—ë„ˆì§€ë¥¼ 50% ê°ì†Œì‹œí‚µë‹ˆë‹¤.' },
            { id: 9, name: 'ì—°ì† ê³µê²©', type: 'attack', cost: 30, power: 10, target: 'enemy', effect: 'repeat', desc: 'ë‚®ì€ í”¼í•´ë¥¼ 3íšŒ ê°€í•©ë‹ˆë‹¤.' },
            { id: 10, name: 'ê¸´ê¸‰ ì¶©ì „', type: 'utility', cost: 5, power: 30, target: 'self', effect: 'instant_energy', desc: 'ì¦‰ì‹œ ì—ë„ˆì§€ë¥¼ íšŒë³µí•©ë‹ˆë‹¤. (30)' },

            // ID 11-15: ë²„í”„
            { id: 11, name: 'ë¶„ë…¸ í­ë°œ', type: 'buff', cost: 15, power: 2, target: 'self', effect: 'rage', desc: 'ë‹¤ìŒ 3í„´ê°„ ìì‹ ì˜ ê³µê²©ë ¥ì´ 2ë°°ê°€ ë©ë‹ˆë‹¤.' },
            { id: 12, name: 'ì¬ìƒì˜ ì•ˆê°œ', type: 'buff', cost: 20, power: 10, target: 'self', effect: 'regen', desc: 'ë‹¤ìŒ 2í„´ê°„ ë§¤ í„´ ì²´ë ¥ì„ íšŒë³µí•©ë‹ˆë‹¤.' },
            { id: 13, name: 'ì •í™”', type: 'utility', cost: 10, power: 0, target: 'self', effect: 'clear_debuff', desc: 'ìì‹ ì—ê²Œ ê±¸ë¦° ëª¨ë“  ë””ë²„í”„ë¥¼ ì œê±°í•©ë‹ˆë‹¤.' },
            { id: 14, name: 'ì¼ê²© í•„ì‚´', type: 'attack', cost: 40, power: 50, target: 'enemy', effect: null, desc: 'ë§‰ëŒ€í•œ í”¼í•´ë¥¼ ì£¼ì§€ë§Œ ì—ë„ˆì§€ ì†Œëª¨ê°€ í½ë‹ˆë‹¤.' },
            { id: 15, name: 'í¡í˜ˆ ê³µê²©', type: 'attack', cost: 20, power: 20, target: 'enemy', effect: 'lifesteal', desc: 'í”¼í•´ëŸ‰ì˜ 50%ë§Œí¼ ì²´ë ¥ì„ í¡ìˆ˜í•©ë‹ˆë‹¤.' },

            // ID 16-20: ìƒíƒœ íš¨ê³¼ í™œìš©
            { id: 16, name: 'ì—­ë³‘ í™•ì‚°', type: 'debuff', cost: 10, power: 0, target: 'enemy', effect: 'poison_stack', desc: 'ìƒëŒ€ë°©ì—ê²Œ ë… ìŠ¤íƒì„ ì¶”ê°€í•©ë‹ˆë‹¤.' },
            { id: 17, name: 'ë°©íŒ¨ ê°•í™”', type: 'buff', cost: 10, power: 0, target: 'self', effect: 'defense_stack', desc: 'ë°©ì–´ë ¥ ìŠ¤íƒì„ 1 ì¦ê°€ì‹œí‚µë‹ˆë‹¤. (ìµœëŒ€ 3ìŠ¤íƒ, í”¼í•´ ê°ì†Œ +10/ìŠ¤íƒ)' },
            { id: 18, name: 'ê¸‰ì† ì¹˜ë£Œ', type: 'heal', cost: 15, power: 15, target: 'self', effect: 'instant_heal', desc: 'ì¦‰ì‹œ ì²´ë ¥ì„ ì†ŒëŸ‰ íšŒë³µí•©ë‹ˆë‹¤.' },
            { id: 19, name: 'ì •ì‹  ì§‘ì¤‘', type: 'utility', cost: 0, power: 0, target: 'self', effect: 'wait', desc: 'ë‹¤ìŒ í„´ ì—ë„ˆì§€ íšŒë³µëŸ‰ì„ 2ë°°ë¡œ ë§Œë“­ë‹ˆë‹¤.' },
            { id: 20, name: 'ìš´ëª…ì˜ ì£¼ì‚¬ìœ„', type: 'attack', cost: 10, power: 40, target: 'enemy', effect: 'random_miss', desc: '50% í™•ë¥ ë¡œ ë§¤ìš° í° í”¼í•´, 50% í™•ë¥ ë¡œ ë¹—ë‚˜ê°.' },
            
            // ID 21-25: ì „ëµ ë° ìœ í‹¸ì„±
            { id: 21, name: 'ë°©íŒ¨ ë¶€ìˆ˜ê¸°', type: 'attack', cost: 15, power: 20, target: 'enemy', effect: 'remove_defense', desc: 'í”¼í•´ë¥¼ ì£¼ê³  ìƒëŒ€ì˜ ëª¨ë“  ë°©ì–´ ìŠ¤íƒì„ ì œê±°í•©ë‹ˆë‹¤.' },
            { id: 22, name: 'ë§ˆë‚˜ í¡ìˆ˜', type: 'attack', cost: 5, power: 10, target: 'enemy', effect: 'mana_steal', desc: 'ì†ŒëŸ‰ì˜ í”¼í•´ë¥¼ ì£¼ê³  í”¼í•´ëŸ‰ë§Œí¼ ìì‹ ì˜ ì—ë„ˆì§€ë¥¼ íšŒë³µí•©ë‹ˆë‹¤.' },
            { id: 23, name: 'ì„ì‹œ ë³´í˜¸ë§‰', type: 'defend', cost: 20, power: 30, target: 'self', effect: 'shield', desc: '30 í”¼í•´ë¥¼ í¡ìˆ˜í•˜ëŠ” ë³´í˜¸ë§‰ì„ ìƒì„±í•©ë‹ˆë‹¤. (ëˆ„ì  ë¶ˆê°€)' },
            { id: 24, name: 'ì‹œê°„ ê°€ì†', type: 'utility', cost: 50, power: 0, target: 'self', effect: 'extra_turn', desc: 'ë§¤ìš° ë†’ì€ ì—ë„ˆì§€ ì†Œëª¨ë¡œ ì¦‰ì‹œ í•œ ë²ˆ ë” í„´ì„ ì–»ìŠµë‹ˆë‹¤. (ì¬ì‚¬ìš© ì‹œ ì—ë„ˆì§€ 100 ì†Œëª¨)' },
            { id: 25, name: 'ì¹˜ëª…íƒ€ ì§‘ì¤‘', type: 'buff', cost: 10, power: 0, target: 'self', effect: 'crit_focus', desc: 'ë‹¤ìŒ ê³µê²©ì„ ì¹˜ëª…íƒ€(1.5ë°° í”¼í•´)ë¡œ ë§Œë“­ë‹ˆë‹¤.' },
            
            // ID 26-30: ê³ ìœ„ ìŠ¤í‚¬
            { id: 26, name: 'ë°˜ê²©ì˜ ë¶ˆê½ƒ', type: 'attack', cost: 25, power: 30, target: 'enemy', effect: 'backfire', desc: 'ìƒëŒ€ì—ê²Œ í° í”¼í•´ë¥¼ ì£¼ì§€ë§Œ ìì‹ ë„ 10 í”¼í•´ë¥¼ ì…ìŠµë‹ˆë‹¤.' },
            { id: 27, name: 'ì‹ ì„±í•œ ì¹˜ìœ ', type: 'heal', cost: 35, power: 50, target: 'self', effect: null, desc: 'ë§ì€ ì—ë„ˆì§€ë¥¼ ì†Œëª¨í•˜ì—¬ ì²´ë ¥ì„ ëŒ€ëŸ‰ íšŒë³µí•©ë‹ˆë‹¤.' },
            { id: 28, name: 'ì—ë„ˆì§€ ê³ ê°ˆ', type: 'debuff', cost: 15, power: 0, target: 'enemy', effect: 'energy_drain', desc: 'ìƒëŒ€ë°©ì˜ í˜„ì¬ ì—ë„ˆì§€ë¥¼ 20 ê°ì†Œì‹œí‚µë‹ˆë‹¤.' },
            { id: 29, name: 'ì¶©ê²©íŒŒ', type: 'attack', cost: 45, power: 25, target: 'enemy', effect: 'stun', desc: 'í”¼í•´ë¥¼ ì£¼ê³  ë‹¤ìŒ í„´ ìƒëŒ€ë°©ì„ ê¸°ì ˆì‹œì¼œ í„´ì„ ê±´ë„ˆë›°ê²Œ í•©ë‹ˆë‹¤.' },
            { id: 30, name: 'ë³µìˆ˜ì˜ ì¹¼ë‚ ', type: 'attack', cost: 10, power: 35, target: 'enemy', effect: 'vengeance', desc: 'ìì‹ ì˜ ìƒì€ ì²´ë ¥ 10ë§ˆë‹¤ í”¼í•´ëŸ‰ì´ 5ì”© ì¦ê°€í•©ë‹ˆë‹¤.' },
            
            // ID 31-40: ì‹ ê·œ ìŠ¤í‚¬ (í™•ì¥)
            { id: 31, name: 'ì§€ì—° í­ë°œ', type: 'attack', cost: 25, power: 20, target: 'enemy', effect: 'delayed_bomb', desc: 'í”¼í•´ë¥¼ ì£¼ê³  2í„´ í›„ 40 ì¶”ê°€ í”¼í•´ë¥¼ ì£¼ëŠ” í­íƒ„ì„ ì‹¬ìŠµë‹ˆë‹¤.' },
            { id: 32, name: 'í¬ìƒ ëŒê²©', type: 'attack', cost: 'HP(20%)', power: 45, target: 'enemy', effect: 'hp_cost', desc: 'í˜„ì¬ ì²´ë ¥ 20%ë¥¼ ì†Œëª¨í•˜ì—¬ ë§‰ëŒ€í•œ í”¼í•´ë¥¼ ì¤ë‹ˆë‹¤.' },
            { id: 33, name: 'ì™„ë²½ ë°©ì–´', type: 'defend', cost: 15, power: 40, target: 'self', effect: 'immunity', desc: 'ë‹¤ìŒ í„´ ë°›ëŠ” í”¼í•´ë¥¼ í¬ê²Œ ì¤„ì´ê³ , ëª¨ë“  ìƒíƒœ ì´ìƒì— ë©´ì—­ì´ ë©ë‹ˆë‹¤.' },
            { id: 34, name: 'ì—ë„ˆì§€ êµí™˜', type: 'utility', cost: 10, power: 0, target: 'enemy', effect: 'energy_swap', desc: 'ìƒëŒ€ì™€ ìì‹ ì˜ í˜„ì¬ ì—ë„ˆì§€ë¥¼ ë§ë°”ê¿‰ë‹ˆë‹¤.' },
            { id: 35, name: 'ê²°ì •ì  ì¹˜ìœ ', type: 'heal', cost: 30, power: 30, target: 'self', effect: 'crit_heal', desc: 'ì²´ë ¥ì„ íšŒë³µí•©ë‹ˆë‹¤. ì²´ë ¥ì´ 30% ë¯¸ë§Œì¼ ê²½ìš° íšŒë³µëŸ‰ì´ 2ë°°ê°€ ë©ë‹ˆë‹¤.' },
            { id: 36, name: 'ì‹¤ëª… ê´‘ì„ ', type: 'debuff', cost: 10, power: 0, target: 'enemy', effect: 'blind', desc: 'ìƒëŒ€ì—ê²Œ ì‹¤ëª…ì„ ê±¸ì–´ 2í„´ê°„ ê³µê²©ì´ 30% í™•ë¥ ë¡œ ë¹—ë‚˜ê°€ê²Œ í•©ë‹ˆë‹¤.' },
            { id: 37, name: 'ë¶€í™œ í”„ë¡œí† ì½œ', type: 'utility', cost: 30, power: 0, target: 'self', effect: 'revive_flag', desc: 'ì´ ìŠ¤í‚¬ì„ ì‚¬ìš©í•˜ë©´, ì´ë²ˆ ì „íˆ¬ì—ì„œ 1íšŒì— í•œí•´ ì²´ë ¥ 0ì´ ë  ë•Œ 15 HPë¡œ ë¶€í™œí•©ë‹ˆë‹¤.' },
            { id: 38, name: 'ì—°ì‡„ ë²ˆê°œ', type: 'attack', cost: 20, power: 20, target: 'enemy', effect: 'chain', desc: 'í”¼í•´ë¥¼ ì£¼ê³ , ìƒëŒ€ì—ê²Œ ë””ë²„í”„ê°€ ìˆì„ ê²½ìš° 10 ì¶”ê°€ í”¼í•´ë¥¼ ì¤ë‹ˆë‹¤.' },
            { id: 39, name: 'ì—ë„ˆì§€ ë³€í™˜', type: 'heal', cost: 15, power: 30, target: 'self', effect: 'convert_e_to_hp', desc: 'ì—ë„ˆì§€ 15ë¥¼ ì†Œëª¨í•˜ì—¬ ì²´ë ¥ 30ì„ íšŒë³µí•©ë‹ˆë‹¤. (íš¨ìœ¨ 2ë°°)' },
            // ID 40: í•„ë©¸ì˜ ê³„ì•½ (Final Replacement)
            { id: 40, name: 'í•„ë©¸ì˜ ê³„ì•½', type: 'debuff', cost: 40, power: 0, target: 'enemy', effect: 'mortal_contract', desc: '1í„´ê°„ ìƒëŒ€ì—ê²Œ ê³„ì•½ì„ ê²ë‹ˆë‹¤. ê³„ì•½ ìƒíƒœì—ì„œ ìƒëŒ€ê°€ ìŠ¤í‚¬ì„ ì‚¬ìš©í•˜ë©´, ìƒëŒ€ê°€ ì…íŒ í”¼í•´ëŸ‰ì˜ 150%ë¥¼ ì‹œì „ìê°€ íšŒë³µí•©ë‹ˆë‹¤.' },
        ];

        // Game State for Battle
        let gameState = {};
        
        // Setup State for Skill Selection
        let setupState = {
            p1SelectedSkills: [], // Array of skill IDs
            p2SelectedSkills: [],
            isP1Ready: false,
            isP2Ready: false
        };

        // --- ì¶”ê°€ëœ ê²Œì„ ìƒíƒœ ë³€ìˆ˜ ---
        let isGamePending = false; // 5ì´ˆ ìŠ¹ë¦¬ íŒì • ëŒ€ê¸° ì¤‘ì¸ì§€ ì—¬ë¶€

        // UI elements
        const setupScreen = document.getElementById('setup-screen');
        const battleScreen = document.getElementById('battle-screen');
        const startBattleBtn = document.getElementById('start-battle-btn');
        const gameStatusText = document.getElementById('game-status-text');
        const logOutput = document.getElementById('log-output');

        function getInitialPlayerState(id, name, skillIds) {
            return {
                id,
                name,
                maxHp: MAX_HP,
                currentHp: MAX_HP,
                maxEnergy: MAX_ENERGY,
                currentEnergy: MAX_ENERGY,
                skills: skillIds.map(skillId => SKILLS.find(s => s.id === skillId)).filter(s => s), 
                // --- New Player Attributes ---
                canRevive: false, // ID 37: ë¶€í™œ í”„ë¡œí† ì½œ í”Œë˜ê·¸
                // -----------------------------
                status: {
                    defense: 0,      
                    rage: 0,         
                    poison: 0,       
                    slow: 0,         
                    regen: 0,        
                    wait: 0,         
                    defense_stack: 0,
                    poison_stack: 0, 
                    shield: 0,       
                    crit_focus: 0,   
                    stun: 0,
                    
                    // --- New Status Effects (31-40) ---
                    immunity: 0,      // ID 33: ìƒíƒœì´ìƒ ë©´ì—­ (í„´ ìˆ˜)
                    blind: 0,         // ID 36: ì‹¤ëª… (í„´ ìˆ˜)
                    mortal_contract: 0, // ID 40: í•„ë©¸ì˜ ê³„ì•½ (í„´ ìˆ˜)
                    statusBomb: { duration: 0, damage: 0 }, // ID 31: ì§€ì—° í­ë°œ
                }
            };
        }

        // --- Setup Logic (unchanged) ---
        window.toggleSkillSelection = function(playerNum, skillId) {
            const stateKey = `p${playerNum}SelectedSkills`;
            const selectedArray = setupState[stateKey];
            
            const index = selectedArray.indexOf(skillId);

            if (index > -1) {
                selectedArray.splice(index, 1);
            } else {
                if (selectedArray.length < MAX_SKILLS_PER_PLAYER) {
                    selectedArray.push(skillId);
                } else {
                    // Custom Alert: Use console log and simple UI feedback instead of window.alert
                    console.error(`Player ${playerNum} cannot select more than ${MAX_SKILLS_PER_PLAYER} skills.`);
                    gameStatusText.textContent = `âŒ í”Œë ˆì´ì–´ ${playerNum}ëŠ” ìµœëŒ€ ${MAX_SKILLS_PER_PLAYER}ê°œì˜ ìŠ¤í‚¬ë§Œ ì„ íƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.`;
                    setTimeout(() => renderSetupUI(), 2000);
                    return;
                }
            }
            
            setupState[`isP${playerNum}Ready`] = selectedArray.length === MAX_SKILLS_PER_PLAYER;
            renderSetupUI();
        }

        function renderSetupUI() {
            renderMasterSkillList();
            renderSelectedSkills(1);
            renderSelectedSkills(2);

            const isReady = setupState.isP1Ready && setupState.isP2Ready;
            startBattleBtn.disabled = !isReady;
            startBattleBtn.textContent = isReady ? 'ì „íˆ¬ ì‹œì‘' : `${setupState.isP1Ready ? 'P2 ëŒ€ê¸° ì¤‘' : 'P1 ëŒ€ê¸° ì¤‘'} (6ê°œ ì„ íƒ í•„ìˆ˜)`;
            if (!isReady) {
                 gameStatusText.textContent = 'ìŠ¤í‚¬ì„ ì„ íƒí•˜ê³  ì¤€ë¹„í•˜ì„¸ìš”.';
            }
        }

        function renderSelectedSkills(playerNum) {
            const container = document.getElementById(`p${playerNum}-selected-skills`);
            const selectedIds = setupState[`p${playerNum}SelectedSkills`];
            const countEl = document.getElementById(`p${playerNum}-selection-count`);
            
            container.innerHTML = '';
            countEl.textContent = `ì„ íƒí•œ ìŠ¤í‚¬: ${selectedIds.length} / ${MAX_SKILLS_PER_PLAYER}`;

            if (selectedIds.length === 0) {
                container.innerHTML = `<p class="text-gray-400 text-sm italic">ì„ íƒëœ ìŠ¤í‚¬ ì—†ìŒ</p>`;
                return;
            }

            selectedIds.forEach(skillId => {
                const skill = SKILLS.find(s => s.id === skillId);
                if (skill) {
                    const pill = document.createElement('span');
                    pill.className = `px-3 py-1 text-xs font-medium rounded-full text-white ${playerNum === 1 ? 'bg-blue-600' : 'bg-red-600'} cursor-pointer hover:bg-opacity-80`;
                    pill.textContent = skill.name;
                    pill.onclick = () => toggleSkillSelection(playerNum, skillId);
                    container.appendChild(pill);
                }
            });
        }

        function renderMasterSkillList() {
            const container = document.getElementById('master-skill-list');
            container.innerHTML = '';

            SKILLS.forEach(skill => {
                const isP1Selected = setupState.p1SelectedSkills.includes(skill.id);
                const isP2Selected = setupState.p2SelectedSkills.includes(skill.id);
                
                const item = document.createElement('div');
                item.className = `skill-select-item p-3 rounded-lg text-center shadow-md border ${isP1Selected && isP2Selected ? 'bg-purple-900 border-purple-400' : isP1Selected ? 'bg-blue-900 border-blue-400' : isP2Selected ? 'bg-red-900 border-red-400' : 'bg-slate-700 border-slate-600'}`;
                
                // Set Cost for display
                const costText = (skill.cost === 'HP(20%)') ? 'â¤ï¸ HP 20%' : `${skill.cost}E`;

                item.innerHTML = `
                    <p class="text-lg font-semibold text-white">${skill.name} <span class="text-yellow-300 text-sm">(${costText})</span></p>
                    <p class="text-xs text-gray-400 mb-2">${skill.desc}</p>
                    <div class="flex justify-center gap-2 mt-2">
                        <button class="text-xs py-1 px-3 rounded-full font-medium transition duration-150 ${isP1Selected ? 'bg-red-500 text-white' : 'bg-blue-500 text-white hover:bg-blue-600'}"
                                onclick="toggleSkillSelection(1, ${skill.id})">
                            P1 ${isP1Selected ? 'ì·¨ì†Œ' : 'ì„ íƒ'}
                        </button>
                        <button class="text-xs py-1 px-3 rounded-full font-medium transition duration-150 ${isP2Selected ? 'bg-blue-500 text-white' : 'bg-red-500 text-white hover:bg-red-600'}"
                                onclick="toggleSkillSelection(2, ${skill.id})">
                            P2 ${isP2Selected ? 'ì·¨ì†Œ' : 'ì„ íƒ'}
                        </button>
                    </div>
                `;
                container.appendChild(item);
            });
        }

        window.startBattle = function() {
            if (!setupState.isP1Ready || !setupState.isP2Ready) {
                return;
            }
            
            logOutput.innerHTML = '';
            
            gameState = {
                player1: getInitialPlayerState(1, 'í”Œë ˆì´ì–´ 1', setupState.p1SelectedSkills),
                player2: getInitialPlayerState(2, 'í”Œë ˆì´ì–´ 2', setupState.p2SelectedSkills),
                currentPlayerId: 1, 
                isGameOver: false,
                turnCount: 1,
            };
            isGamePending = false; 

            setupScreen.classList.add('hidden');
            battleScreen.classList.remove('hidden');

            logMessage('[ì‹œìŠ¤í…œ] ìƒˆë¡œìš´ ì „íˆ¬ê°€ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤!', 'text-green-400');
            logMessage(`[ì‹œìŠ¤í…œ] í”Œë ˆì´ì–´ 1: ${gameState.player1.skills.map(s => s.name).join(', ')}`, 'text-blue-300');
            logMessage(`[ì‹œìŠ¤í…œ] í”Œë ˆì´ì–´ 2: ${gameState.player2.skills.map(s => s.name).join(', ')}`, 'text-red-300');
            renderBattleUI();
        }

        window.showSetupScreen = function() {
            battleScreen.classList.add('hidden');
            setupScreen.classList.remove('hidden');
            hideModal();
            renderSetupUI();
        }


        // --- Core Game Logic ---
        function getActivePlayer() {
            return gameState.currentPlayerId === 1 ? gameState.player1 : gameState.player2;
        }

        function getTargetPlayer() {
            return gameState.currentPlayerId === 1 ? gameState.player2 : gameState.player1;
        }
        
        /**
         * ë°ë¯¸ì§€ ê³„ì‚° ë° ì ìš© í•¨ìˆ˜ (ì‹¤ë“œ, ë¶€í™œ ë¡œì§ ì¶”ê°€)
         */
        function applyDamage(target, amount) {
            if (gameState.isGameOver || isGamePending) return;
            
            let finalDamage = amount;
            let damageLog = [];
            
            // 1. Defense (stacks and temporary)
            let defense = target.status.defense + (target.status.defense_stack * 10);
            if (defense > 0) damageLog.push(`[ë°©ì–´ë ¥ ${defense}]`);
            finalDamage = Math.max(0, finalDamage - defense);

            // 2. Shield Absorption
            let damageAbsorbedByShield = 0;
            if (target.status.shield > 0) {
                damageAbsorbedByShield = Math.min(finalDamage, target.status.shield);
                target.status.shield -= damageAbsorbedByShield;
                finalDamage -= damageAbsorbedByShield;
                if (damageAbsorbedByShield > 0) {
                    damageLog.push(`[ë³´í˜¸ë§‰ ${damageAbsorbedByShield} í¡ìˆ˜] (ë‚¨ì€ ì‹¤ë“œ: ${target.status.shield})`);
                }
            }
            
            // 3. Apply Damage to HP
            target.currentHp = Math.max(0, target.currentHp - finalDamage);

            logMessage(`[${target.name}] ${damageLog.join(', ')} ${finalDamage} í”¼í•´ë¥¼ ì…ì—ˆìŠµë‹ˆë‹¤. (ë‚¨ì€ ì²´ë ¥: ${target.currentHp})`, finalDamage > 0 ? 'text-red-400' : 'text-gray-400');
            
            // 4. [NEW] Revive Protocol Check (ID 37)
            if (target.currentHp <= 0 && target.canRevive) {
                target.currentHp = 15;
                target.canRevive = false; // 1íšŒìš© ì†Œëª¨
                logMessage(`[${target.name}] âœ¨ ë¶€í™œ í”„ë¡œí† ì½œ ë°œë™! 15 HPë¡œ íšŒë³µë˜ì—ˆìŠµë‹ˆë‹¤! (ì†Œëª¨ë¨)`, 'text-green-500');
            }

            checkGameOver();
            return finalDamage; // Return the actual damage dealt for contract calculation
        }

        function applyHeal(target, amount) {
            if (gameState.isGameOver || isGamePending) return;
            const actualHeal = Math.min(target.maxHp - target.currentHp, amount);
            target.currentHp += actualHeal;
            logMessage(`[${target.name}] ì²´ë ¥ ${actualHeal}ì„ íšŒë³µí–ˆìŠµë‹ˆë‹¤. (í˜„ì¬ ì²´ë ¥: ${target.currentHp})`, 'text-green-400');
        }

        function applyStatusEffects(player) {
            if (gameState.isGameOver || isGamePending) return;

            // 1. Poison Damage
            if (player.status.poison > 0 || player.status.poison_stack > 0) {
                const poisonDmg = (player.status.poison > 0 ? 5 : 0) + (player.status.poison_stack * 5);
                logMessage(`[${player.name}] ğŸ§ª ë…ì— ì˜í•´ ${poisonDmg} í”¼í•´ë¥¼ ì…ìŠµë‹ˆë‹¤.`, 'text-purple-400');
                applyDamage(player, poisonDmg);
                if (gameState.isGameOver || isGamePending) return;
            }

            // 2. Regen Heal
            if (player.status.regen > 0) {
                applyHeal(player, 10);
            }

            // 3. [NEW] Delayed Bomb Ticking (ID 31)
            if (player.status.statusBomb.duration > 0) {
                player.status.statusBomb.duration--;
                if (player.status.statusBomb.duration === 0) {
                    logMessage(`[${player.name}] ğŸ’¥ ì§€ì—° í­íƒ„ì´ í„°ì ¸ ${player.status.statusBomb.damage} í”¼í•´ë¥¼ ì…ìŠµë‹ˆë‹¤!`, 'text-red-600');
                    applyDamage(player, player.status.statusBomb.damage);
                    player.status.statusBomb = { duration: 0, damage: 0 };
                    if (gameState.isGameOver || isGamePending) return;
                } else {
                    logMessage(`[${player.name}] ì§€ì—° í­íƒ„ ì¹´ìš´íŠ¸: ${player.status.statusBomb.duration} í„´ ë‚¨ìŒ.`, 'text-orange-300');
                }
            }


            // 4. Status duration decrease 
            ['defense', 'rage', 'poison', 'slow', 'regen', 'wait', 'stun', 'immunity', 'blind', 'mortal_contract'].forEach(effect => {
                if (player.status[effect] > 0) {
                    player.status[effect]--;
                    if (player.status[effect] === 0) {
                        logMessage(`[${player.name}] ${getStatusName(effect)} íš¨ê³¼ê°€ í•´ì œë˜ì—ˆìŠµë‹ˆë‹¤.`, 'text-gray-500');
                        if (effect === 'defense') player.status.defense = 0;
                    }
                }
            });
        }

        function getStatusName(key) {
            const names = {
                defense: 'ë°©ì–´ë§‰',
                rage: 'ë¶„ë…¸',
                poison: 'ë…',
                slow: 'ë‘”í™”',
                silence: 'ì¹¨ë¬µ',
                regen: 'ì¬ìƒ',
                wait: 'ì§‘ì¤‘',
                defense_stack: 'ê°•í™” ë°©íŒ¨',
                poison_stack: 'ëˆ„ì  ë…',
                shield: 'ë³´í˜¸ë§‰',
                crit_focus: 'ì¹˜ëª…íƒ€ ì§‘ì¤‘',
                stun: 'ê¸°ì ˆ',
                immunity: 'ë©´ì—­', // ID 33
                blind: 'ì‹¤ëª…',     // ID 36
                mortal_contract: 'í•„ë©¸ì˜ ê³„ì•½', // ID 40
            };
            return names[key] || key;
        }

        window.handleSkillUse = function(skill) {
            if (gameState.isGameOver || isGamePending) return false; 

            const activePlayer = getActivePlayer();
            const targetPlayer = getTargetPlayer();
            const isTargetUnderContract = targetPlayer.status.mortal_contract > 0;
            const casterPlayer = activePlayer;
            const targetOfContract = gameState.currentPlayerId === 1 ? gameState.player2 : gameState.player1;
            const casterOfContract = gameState.currentPlayerId === 1 ? gameState.player1 : gameState.player2; // If target is under contract, this is the player who cast it

            // 1. Contract Check (If the active player is under the contract, they are the targetPlayer from the caster's perspective)
            if (isTargetUnderContract) {
                if (skill.type === 'attack' || skill.cost === 'HP(20%)') {
                    logMessage(`[${activePlayer.name}] âŒ í•„ë©¸ì˜ ê³„ì•½ ìƒíƒœì—ì„œëŠ” ê³µê²© ìŠ¤í‚¬ì„ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤!`, 'text-red-700');
                    return false;
                }
            }


            // 2. Calculate Cost (Energy or HP)
            let actualEnergyCost = skill.cost;
            let hpCost = 0;
            
            if (skill.cost === 'HP(20%)') { // ID 32: í¬ìƒ ëŒê²©
                hpCost = Math.ceil(activePlayer.currentHp * 0.2);
                actualEnergyCost = 0;
            } else if (skill.effect === 'extra_turn' && activePlayer.status.extraTurnUsed) { // ID 24
                actualEnergyCost = 100;
            } else if (skill.effect === 'convert_e_to_hp') { // ID 39
                // Cost is already defined in skill.cost (15E)
            }


            // 3. Check Feasibility
            if (actualEnergyCost > 0 && activePlayer.currentEnergy < actualEnergyCost) {
                logMessage(`[${activePlayer.name}] ì—ë„ˆì§€ê°€ ë¶€ì¡±í•©ë‹ˆë‹¤. (í•„ìš” ì—ë„ˆì§€: ${actualEnergyCost})`, 'text-yellow-500');
                return false;
            }
            if (hpCost > 0 && activePlayer.currentHp <= hpCost) {
                 logMessage(`[${activePlayer.name}] ì²´ë ¥ì´ ë¶€ì¡±í•©ë‹ˆë‹¤. (í•„ìš” HP: ${hpCost})`, 'text-red-500');
                return false;
            }
            
            // 4. Pay Cost
            activePlayer.currentEnergy -= actualEnergyCost;
            let selfDamageTaken = 0;
            if (hpCost > 0) {
                selfDamageTaken = applyDamage(activePlayer, hpCost);
                if (gameState.isGameOver || isGamePending) return true; // Could win the game with self-damage
            }
            logMessage(`[${activePlayer.name}] ${skill.name}ì„(ë¥¼) ì‚¬ìš©! (ë¹„ìš©: ${hpCost > 0 ? hpCost + ' HP' : actualEnergyCost + ' E'} ì†Œëª¨)`, 'text-blue-500');

            // --- Skill Effects ---
            let basePower = skill.power;
            let finalPower = basePower;
            let lifestealAmount = 0;
            let missingHp = activePlayer.maxHp - activePlayer.currentHp;
            let damageDealt = 0;


            // Pre-Attack Buffs/Debuffs (Attacker Side)
            if (skill.type === 'attack' || skill.cost === 'HP(20%)') {
                
                // Check Blind (Attacker) [NEW]
                if (activePlayer.status.blind > 0 && Math.random() < 0.3) {
                    logMessage(`[${activePlayer.name}] ğŸ˜µ ì‹¤ëª… ìƒíƒœë¡œ ê³µê²©ì´ ë¹—ë‚˜ê°”ìŠµë‹ˆë‹¤!`, 'text-gray-500');
                    // Skip the rest of the attack effects
                    endTurn();
                    return true;
                }

                if (activePlayer.status.rage > 0) {
                    finalPower *= 2;
                    logMessage(`[${activePlayer.name}] ë¶„ë…¸ íš¨ê³¼ë¡œ í”¼í•´ëŸ‰ì´ 2ë°°ê°€ ë©ë‹ˆë‹¤.`, 'text-orange-400');
                }
                
                // Critical Focus Buff (ID 25)
                if (activePlayer.status.crit_focus > 0) {
                    finalPower = Math.floor(finalPower * 1.5); 
                    activePlayer.status.crit_focus = 0; 
                    logMessage(`[${activePlayer.name}] ğŸ’¥ ì§‘ì¤‘ ê³µê²©! ì¹˜ëª…íƒ€(1.5ë°° í”¼í•´)ê°€ ë°œë™ë˜ì—ˆìŠµë‹ˆë‹¤.`, 'text-pink-500');
                }

                if (activePlayer.status.slow > 0) {
                     finalPower = Math.max(1, finalPower - 15);
                     logMessage(`[${activePlayer.name}] ë‘”í™” íš¨ê³¼ë¡œ í”¼í•´ëŸ‰ì´ ê°ì†Œí•©ë‹ˆë‹¤.`, 'text-cyan-400');
                }
                
                // Vengeance (ID 30)
                if (skill.effect === 'vengeance') {
                    const extraDmg = Math.floor(missingHp / 10) * 5;
                    finalPower += extraDmg;
                    logMessage(`[${activePlayer.name}] ìƒì€ ì²´ë ¥ (${missingHp})ì— ë¹„ë¡€í•˜ì—¬ í”¼í•´ëŸ‰ì´ ${extraDmg} ì¦ê°€í•©ë‹ˆë‹¤.`, 'text-orange-300');
                }
                
                // Chain Lightning (ID 38)
                if (skill.effect === 'chain') {
                    const hasDebuff = Object.keys(targetPlayer.status).some(key => {
                        const val = targetPlayer.status[key];
                        return (typeof val === 'number' && val > 0 && key !== 'defense' && key !== 'defense_stack') || 
                               (typeof val === 'object' && val.duration > 0);
                    });
                    if (hasDebuff) {
                        finalPower += 10;
                        logMessage(`[${activePlayer.name}] ì—°ì‡„ ë²ˆê°œ! ìƒëŒ€ ë””ë²„í”„ ê°ì§€, 10 ì¶”ê°€ í”¼í•´!`, 'text-indigo-400');
                    }
                }
            }
            
            // 5. Attack/Damage
            if (skill.type === 'attack' || skill.cost === 'HP(20%)') { // Include HP cost skill here
                
                // Shield Break (ID 21)
                if (skill.effect === 'remove_defense') {
                    targetPlayer.status.defense_stack = 0;
                    logMessage(`[${targetPlayer.name}] ë°©íŒ¨ ë¶€ìˆ˜ê¸°! ëª¨ë“  ë°©ì–´ ìŠ¤íƒì´ ì œê±°ë˜ì—ˆìŠµë‹ˆë‹¤.`, 'text-yellow-500');
                }
                
                // Backfire (ID 26) - Self damage was paid as cost or handled outside, but this is immediate damage backfire
                if (skill.effect === 'backfire') {
                    applyDamage(activePlayer, 10); 
                    logMessage(`[${activePlayer.name}] ë°˜ê²©ì˜ ë¶ˆê½ƒì˜ ë°˜ë™ìœ¼ë¡œ 10 í”¼í•´ë¥¼ ì…ì—ˆìŠµë‹ˆë‹¤.`, 'text-red-500');
                    if (gameState.isGameOver || isGamePending) return true;
                }
                
                // Deal Damage
                if (skill.effect === 'repeat') { 
                    for (let i = 0; i < 3; i++) { 
                        if (targetPlayer.currentHp > 0) damageDealt += applyDamage(targetPlayer, basePower);
                        else break;
                    }
                } else if (skill.effect === 'random_miss') { 
                    if (Math.random() < 0.5) {
                        logMessage(`[${activePlayer.name}] ìš´ëª…ì˜ ì£¼ì‚¬ìœ„ê°€ ë¹—ë‚˜ê°”ìŠµë‹ˆë‹¤! í”¼í•´ ì—†ìŒ.`, 'text-gray-500');
                    } else {
                        damageDealt = applyDamage(targetPlayer, finalPower);
                    }
                } else {
                    damageDealt = applyDamage(targetPlayer, finalPower);
                }
                
                // Post-Attack Effects (Lifesteal, Mana Steal)
                if (skill.effect === 'lifesteal') {
                    lifestealAmount = Math.floor(damageDealt * 0.5); 
                    if (lifestealAmount > 0) {
                         applyHeal(activePlayer, lifestealAmount);
                         logMessage(`[${activePlayer.name}] í¡í˜ˆ íš¨ê³¼ë¡œ ì²´ë ¥ ${lifestealAmount}ì„ í¡ìˆ˜í–ˆìŠµë‹ˆë‹¤.`, 'text-pink-400');
                    }
                }
                
                // Mana Steal (ID 22)
                if (skill.effect === 'mana_steal') {
                    activePlayer.currentEnergy = Math.min(activePlayer.maxEnergy, activePlayer.currentEnergy + damageDealt);
                    logMessage(`[${activePlayer.name}] ë§ˆë‚˜ í¡ìˆ˜ë¡œ ì—ë„ˆì§€ ${damageDealt} íšŒë³µ.`, 'text-purple-300');
                }
                
                // Delayed Bomb (ID 31)
                if (skill.effect === 'delayed_bomb') {
                    if (targetPlayer.status.immunity === 0) {
                        targetPlayer.status.statusBomb = { duration: 2, damage: 40 };
                        logMessage(`[${targetPlayer.name}] ì§€ì—° í­íƒ„ì´ ì¥ì°©ë˜ì—ˆìŠµë‹ˆë‹¤. (2í„´ í›„ í­ë°œ)`, 'text-orange-300');
                    } else {
                        logMessage(`[${targetPlayer.name}] ì™„ë²½ ë°©ì–´ íš¨ê³¼ë¡œ í­íƒ„ ì¥ì°© ì‹¤íŒ¨!`, 'text-yellow-500');
                    }
                }
                
                // Stun (ID 29)
                if (skill.effect === 'stun') {
                    if (targetPlayer.status.immunity === 0) {
                        targetPlayer.status.stun = 1;
                        logMessage(`[${targetPlayer.name}] ğŸ˜µ ê¸°ì ˆ! ë‹¤ìŒ í„´ì„ ê±´ë„ˆëœë‹ˆë‹¤!`, 'text-red-600');
                    } else {
                        logMessage(`[${targetPlayer.name}] ì™„ë²½ ë°©ì–´ íš¨ê³¼ë¡œ ê¸°ì ˆ ë°©ì–´!`, 'text-yellow-500');
                    }
                }
            }
            
            // 6. Contract Resolution (Applies to the player who used the skill, if they are under contract)
            if (casterPlayer.status.mortal_contract > 0) {
                // Since this section executes after the skill's damage/healing has been calculated and applied, 
                // we only care about how much damage the target (i.e., the player who cast the contract) took.
                
                // Determine the original caster of the contract (the one who benefits)
                const contractCaster = gameState.currentPlayerId === 1 ? gameState.player2 : gameState.player1;

                if (damageDealt > 0) {
                    // Contract healing is based on the damage DEALT by the opponent (activePlayer)
                    const contractHeal = Math.floor(damageDealt * 1.5);
                    applyHeal(contractCaster, contractHeal);
                    logMessage(`[${contractCaster.name}] ğŸ’€ í•„ë©¸ì˜ ê³„ì•½ ë°œë™! ${activePlayer.name}ì˜ ê³µê²© í”¼í•´ ${damageDealt}ì— ë¹„ë¡€í•˜ì—¬ ì²´ë ¥ ${contractHeal}ì„ íšŒë³µí•©ë‹ˆë‹¤!`, 'text-green-600');
                } else if (skill.type === 'heal' || skill.effect === 'instant_heal' || skill.effect === 'crit_heal' || skill.effect === 'convert_e_to_hp') {
                    // Contract healing is based on the healing AMOUNT by the opponent (activePlayer)
                    // We need to calculate how much the activePlayer healed themselves
                    // This is complex, so for utility skills, we will assume a fixed small penalty/gain or adjust skill logic.
                    // For simplicity, let's assume 'utility' skills under contract do not trigger the 150% healing, 
                    // only attacks or effects that deal damage (for damageDealt > 0) or directly heal (for the base power).
                    // In this context, the contract only triggers on DAMAGE DEALT by the active player to the opponent.
                    // Since non-attack skills don't deal damage to the opponent, no healing is gained by the contract caster.
                    // The rule is "ì…íŒ í”¼í•´ëŸ‰ì˜ 150%ë¥¼ ì‚¬ìš©ì(ì‹œì „ì)ê°€ ì¦‰ì‹œ ì²´ë ¥ìœ¼ë¡œ íšŒë³µ" -> Only attacks matter.
                }
                // The contract duration will tick down/expire at the end of the turn regardless of skill used.
            }
            
            // 7. Utility / Buff / Debuff / Defend / Heal (Non-Attack Skills)
            else if (skill.type === 'heal' || skill.effect === 'instant_heal') {
                if (skill.effect === 'crit_heal' && activePlayer.currentHp / activePlayer.maxHp < 0.3) { // ID 35
                    applyHeal(activePlayer, skill.power * 2);
                    logMessage(`[${activePlayer.name}] ê²°ì •ì  ì¹˜ìœ  ë°œë™! íšŒë³µëŸ‰ 2ë°°!`, 'text-green-300');
                } else if (skill.effect === 'convert_e_to_hp') { // ID 39
                    applyHeal(activePlayer, skill.power);
                } else {
                    applyHeal(activePlayer, skill.power);
                }
            }
            else {
                const target = skill.target === 'self' ? activePlayer : targetPlayer;

                switch (skill.effect) {
                    case 'defense': 
                        target.status.defense = skill.power;
                        logMessage(`[${target.name}] ë°©ì–´ë ¥ ${skill.power} ì¦ê°€! (ë‹¤ìŒ í„´ê¹Œì§€)`, 'text-yellow-400');
                        break;
                    case 'energy': 
                        target.maxEnergy += 20; 
                        target.currentEnergy = Math.min(target.maxEnergy, target.currentEnergy + 20); 
                        logMessage(`[${target.name}] ìµœëŒ€ ì—ë„ˆì§€ì™€ í˜„ì¬ ì—ë„ˆì§€ê°€ 20 ì¦ê°€í–ˆìŠµë‹ˆë‹¤.`, 'text-yellow-400');
                        break;
                    case 'instant_energy': 
                        target.currentEnergy = Math.min(target.maxEnergy, target.currentEnergy + skill.power);
                        logMessage(`[${target.name}] ì—ë„ˆì§€ë¥¼ ${skill.power} íšŒë³µí–ˆìŠµë‹ˆë‹¤.`, 'text-yellow-400');
                        break;
                    case 'energy_swap': // ID 34
                        [activePlayer.currentEnergy, targetPlayer.currentEnergy] = [targetPlayer.currentEnergy, activePlayer.currentEnergy];
                        logMessage(`[ì‹œìŠ¤í…œ] ì—ë„ˆì§€ êµí™˜ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤. ${activePlayer.name}: ${activePlayer.currentEnergy}E, ${targetPlayer.name}: ${targetPlayer.currentEnergy}E`, 'text-yellow-300');
                        break;
                    case 'revive_flag': // ID 37
                        activePlayer.canRevive = true;
                        logMessage(`[${activePlayer.name}] ë¶€í™œ í”„ë¡œí† ì½œì´ í™œì„±í™”ë˜ì—ˆìŠµë‹ˆë‹¤. (1íšŒ)`, 'text-blue-300');
                        break;

                    // Debuffs (Check Immunity)
                    case 'poison': 
                    case 'slow': 
                    case 'silence': 
                    case 'poison_stack':
                    case 'energy_drain':
                    case 'blind': // ID 36
                    case 'mortal_contract': // ID 40
                        if (target.status.immunity > 0) {
                            logMessage(`[${target.name}] ì™„ë²½ ë°©ì–´ íš¨ê³¼ë¡œ ìƒíƒœ ì´ìƒì´ ë°©ì–´ë˜ì—ˆìŠµë‹ˆë‹¤!`, 'text-yellow-500');
                        } else {
                            if (skill.effect === 'poison') { target.status.poison = 3; logMessage(`[${target.name}] ë… ìƒíƒœì— ê±¸ë ¸ìŠµë‹ˆë‹¤. (3í„´)`, 'text-purple-400'); }
                            else if (skill.effect === 'slow') { target.status.slow = 2; logMessage(`[${target.name}] ë‘”í™” ìƒíƒœì— ê±¸ë ¤ ê³µê²©ë ¥ì´ ê°ì†Œí•©ë‹ˆë‹¤. (2í„´)`, 'text-cyan-400'); }
                            else if (skill.effect === 'silence') { target.currentEnergy = Math.floor(target.currentEnergy / 2); logMessage(`[${target.name}] ì¹¨ë¬µ ìƒíƒœì— ê±¸ë ¤ ì—ë„ˆì§€ê°€ ì ˆë°˜ìœ¼ë¡œ ê°ì†Œí•©ë‹ˆë‹¤!`, 'text-red-500'); }
                            else if (skill.effect === 'poison_stack') {
                                if (target.status.poison_stack < MAX_STATUS_STACKS) { target.status.poison_stack++; logMessage(`[${target.name}] ëˆ„ì  ë… ìŠ¤íƒì´ ${target.status.poison_stack}ìœ¼ë¡œ ì¦ê°€í–ˆìŠµë‹ˆë‹¤.`, 'text-purple-400'); } else { logMessage(`[${target.name}] ëˆ„ì  ë… ìŠ¤íƒì´ ìµœëŒ€ì¹˜ì…ë‹ˆë‹¤.`, 'text-gray-500'); }
                            }
                            else if (skill.effect === 'energy_drain') {
                                const drained = Math.min(target.currentEnergy, 20);
                                target.currentEnergy = Math.max(0, target.currentEnergy - 20);
                                logMessage(`[${target.name}] ì—ë„ˆì§€ê°€ ${drained} ê³ ê°ˆë˜ì—ˆìŠµë‹ˆë‹¤.`, 'text-yellow-500');
                            }
                            else if (skill.effect === 'blind') { target.status.blind = 2; logMessage(`[${target.name}] ì‹¤ëª… ìƒíƒœì— ê±¸ë ¤ ê³µê²©ì´ ë¹—ë‚˜ê°ˆ ìˆ˜ ìˆìŠµë‹ˆë‹¤. (2í„´)`, 'text-gray-500'); }
                            else if (skill.effect === 'mortal_contract') { 
                                target.status.mortal_contract = 1; 
                                logMessage(`[${target.name}] ğŸ’€ í•„ë©¸ì˜ ê³„ì•½! ë‹¤ìŒ í„´ ê³µê²© ìŠ¤í‚¬ ì‚¬ìš© ë¶ˆê°€. (1í„´)`, 'text-red-700'); 
                            }
                        }
                        break;
                    
                    // Buffs
                    case 'rage': target.status.rage = 3; logMessage(`[${target.name}] ë¶„ë…¸ ìƒíƒœ! ë‹¤ìŒ 3í„´ê°„ ê³µê²©ë ¥ì´ 2ë°°ê°€ ë©ë‹ˆë‹¤.`, 'text-orange-400'); break;
                    case 'regen': target.status.regen = 2; logMessage(`[${target.name}] ì¬ìƒ ìƒíƒœ! ë‹¤ìŒ 2í„´ê°„ ë§¤ í„´ ì²´ë ¥ì„ íšŒë³µí•©ë‹ˆë‹¤.`, 'text-green-400'); break;
                    case 'clear_debuff': 
                        // Clear all negative status effects
                        ['poison', 'slow', 'poison_stack', 'stun', 'blind', 'mortal_contract'].forEach(d => target.status[d] = 0);
                        target.status.statusBomb = { duration: 0, damage: 0 }; // Clear bomb too
                        logMessage(`[${target.name}] ëª¨ë“  ë””ë²„í”„ë¥¼ ì œê±°í–ˆìŠµë‹ˆë‹¤.`, 'text-white');
                        break;
                    case 'wait': 
                        target.status.wait = 1; logMessage(`[${target.name}] ì •ì‹ ì„ ì§‘ì¤‘í•©ë‹ˆë‹¤. ë‹¤ìŒ í„´ ì—ë„ˆì§€ íšŒë³µëŸ‰ì´ 2ë°°ê°€ ë©ë‹ˆë‹¤.`, 'text-yellow-400'); break;
                    case 'defense_stack': 
                        if (target.status.defense_stack < MAX_STATUS_STACKS) { target.status.defense_stack++; logMessage(`[${target.name}] ê°•í™” ë°©íŒ¨ ìŠ¤íƒì´ ${target.status.defense_stack}ìœ¼ë¡œ ì¦ê°€í–ˆìŠµë‹ˆë‹¤.`, 'text-blue-400'); } else { logMessage(`[${target.name}] ê°•í™” ë°©íŒ¨ ìŠ¤íƒì´ ìµœëŒ€ì¹˜ì…ë‹ˆë‹¤.`, 'text-gray-500'); }
                        break;
                    case 'shield': 
                        target.status.shield = skill.power;
                        logMessage(`[${target.name}] ë³´í˜¸ë§‰ ${skill.power}ì„(ë¥¼) ìƒì„±í–ˆìŠµë‹ˆë‹¤!`, 'text-blue-400');
                        break;
                    case 'crit_focus': 
                        target.status.crit_focus = 1;
                        logMessage(`[${target.name}] ë‹¤ìŒ ê³µê²©ì€ ë°˜ë“œì‹œ ì¹˜ëª…íƒ€ê°€ ë©ë‹ˆë‹¤!`, 'text-pink-500');
                        break;
                    case 'immunity': // ID 33
                        target.status.immunity = 1;
                        logMessage(`[${target.name}] ğŸ›¡ï¸ 1í„´ê°„ ìƒíƒœ ì´ìƒ ë©´ì—­ì´ ë©ë‹ˆë‹¤!`, 'text-teal-400');
                        break;
                    case 'extra_turn': 
                        activePlayer.status.extraTurnUsed = true;
                        logMessage(`[${activePlayer.name}] ì‹œê°„ ê°€ì†! í„´ì„ í•œ ë²ˆ ë” ì–»ìŠµë‹ˆë‹¤!`, 'text-green-500');
                        renderBattleUI();
                        return true; 
                }
            }


            // End turn sequence
            if (!gameState.isGameOver && !isGamePending) {
                activePlayer.status.extraTurnUsed = false; // Reset extra turn flag if it wasn't used
                endTurn();
            } else if(isGamePending){
                 renderBattleUI();
            }

            return true;
        }

        /**
         * í„´ ì¢…ë£Œ ë° ìƒíƒœ í™•ì¸ ë¡œì§ (ê¸°ì ˆ ë¡œì§ ì¶”ê°€)
         */
        function endTurn() {
            if (gameState.isGameOver || isGamePending) return;

            const activePlayer = getActivePlayer();
            
            // 1. Status effects tick (on the active player who just moved)
            applyStatusEffects(activePlayer);

            if (gameState.isGameOver || isGamePending) return;

            // 2. Switch player
            gameState.currentPlayerId = gameState.currentPlayerId === 1 ? 2 : 1;
            let nextPlayer = getActivePlayer();
            
            // 2.5. Check for STUN (ID 29)
            if (nextPlayer.status.stun > 0) {
                logMessage(`[${nextPlayer.name}] ğŸš¨ ê¸°ì ˆ ìƒíƒœë¡œ ì¸í•´ í„´ì„ ê±´ë„ˆëœë‹ˆë‹¤!`, 'text-red-600');
                nextPlayer.status.stun--; 
                
                // Switch turn back to the other player (who just moved)
                gameState.currentPlayerId = gameState.currentPlayerId === 1 ? 2 : 1;
                nextPlayer = getActivePlayer(); 
                
                logMessage(`[ì‹œìŠ¤í…œ] í„´ì´ ${nextPlayer.name}ì—ê²Œë¡œ ì¦‰ì‹œ ë„˜ì–´ê°‘ë‹ˆë‹¤.`, 'text-yellow-300');
            }
            
            // 3. Energy Regen for the new active player
            let regenAmount = ENERGY_REGEN;
            if (nextPlayer.status.wait > 0) {
                regenAmount *= 2; // Wait effect
                nextPlayer.status.wait = 0; // Consume wait effect
            }
            nextPlayer.currentEnergy = Math.min(nextPlayer.maxEnergy, nextPlayer.currentEnergy + regenAmount);
            logMessage(`[ì‹œìŠ¤í…œ] ${nextPlayer.name}ì˜ í„´ ì‹œì‘! ì—ë„ˆì§€ ${regenAmount} íšŒë³µ. (í˜„ì¬: ${nextPlayer.currentEnergy})`, 'text-yellow-300');
            
            // 3.5. [NEW] Status effects tick (on the new active player *before* their action)
            applyStatusEffects(nextPlayer);

            // 4. Update UI and Turn Count
            gameState.turnCount++;
            renderBattleUI();
        }

        function declareVictory(winner) {
            gameState.isGameOver = true;
            isGamePending = false; 

            logMessage(`[ì‹œìŠ¤í…œ] 5ì´ˆ ëŒ€ê¸° ë. ${winner.name}ê°€ ìµœì¢… ìŠ¹ë¦¬í–ˆìŠµë‹ˆë‹¤!`, 'text-yellow-400 font-bold');
            
            document.getElementById('winner-text').textContent = `${winner.name} ìŠ¹ë¦¬!`;
            showModal();
            renderBattleUI(); 
        }

        /**
         * ì²´ë ¥ 0 ê°ì§€ ë° 5ì´ˆ ëŒ€ê¸° íƒ€ì´ë¨¸ ì„¤ì •
         */
        function checkGameOver() {
            if (gameState.isGameOver || isGamePending) return;

            let winner = null;
            if (gameState.player1.currentHp <= 0) {
                winner = gameState.player2;
            } else if (gameState.player2.currentHp <= 0) {
                winner = gameState.player1;
            }

            if (winner) {
                isGamePending = true;
                logMessage(`[ì‹œìŠ¤í…œ] ğŸ’¥ ì¹˜ëª…íƒ€! íŒ¨ë°° í”Œë ˆì´ì–´ ê°ì§€! ${winner.name}ì˜ ìŠ¹ë¦¬ íŒì •ê¹Œì§€ 5ì´ˆ ëŒ€ê¸°í•©ë‹ˆë‹¤.`, 'text-orange-400');
                
                let countdown = 5;
                const timerInterval = setInterval(() => {
                    countdown--;
                    gameStatusText.textContent = `ğŸš¨ ${winner.name} ìŠ¹ë¦¬ ëŒ€ê¸° ì¤‘... (${countdown}ì´ˆ)`;
                    if (countdown <= 0) {
                        clearInterval(timerInterval);
                    }
                }, 1000);

                setTimeout(() => {
                    if (isGamePending) {
                       declareVictory(winner);
                    }
                }, 5000);
                
                renderBattleUI(); 
            }
        }


        // --- UI Rendering (Battle) ---
        function renderBattleUI() {
            const p1 = gameState.player1;
            const p2 = gameState.player2;
            const activePlayerId = gameState.currentPlayerId;

            if (!isGamePending && !gameState.isGameOver) {
                gameStatusText.textContent = `${activePlayerId === 1 ? p1.name : p2.name}ì˜ í„´ (í„´: ${gameState.turnCount})`;
            } else if (gameState.isGameOver && !isGamePending) {
                 gameStatusText.textContent = `ê²Œì„ ì¢…ë£Œ!`;
            }

            updatePlayerCard(p1, 'player1', activePlayerId === 1 && !isGamePending);
            updatePlayerCard(p2, 'player2', activePlayerId === 2 && !isGamePending);

            const activePlayer = getActivePlayer();
            const currentEnergy = activePlayer.currentEnergy;
            const skills = activePlayer.skills;
            const isUnderContract = activePlayer.status.mortal_contract > 0;
            renderSkills(skills, currentEnergy, gameState.isGameOver || isGamePending, isUnderContract);
        }

        function updatePlayerCard(player, prefix, isActive) {
            const shortPrefix = prefix === 'player1' ? 'p1' : 'p2'; 

            const card = document.getElementById(`${prefix}-card`);
            if (!card) return;

            const hpPercent = (player.currentHp / player.maxHp) * 100;
            const energyPercent = (player.currentEnergy / player.maxEnergy) * 100;

            const hpTextEl = document.getElementById(`${shortPrefix}-hp-text`);
            const hpBarEl = document.getElementById(`${shortPrefix}-hp-bar`);
            const energyTextEl = document.getElementById(`${shortPrefix}-energy-text`);
            const energyBarEl = document.getElementById(`${shortPrefix}-energy-bar`);
            const statusEl = document.getElementById(`${shortPrefix}-status`);

            if (!hpTextEl || !hpBarEl || !energyTextEl || !energyBarEl || !statusEl) return;

            hpTextEl.textContent = `${player.currentHp} / ${player.maxHp}`;
            hpBarEl.style.width = `${hpPercent}%`;
            energyTextEl.textContent = `${player.currentEnergy} / ${player.maxEnergy}`;
            energyBarEl.style.width = `${energyPercent}%`;

            let statusText = [];
            
            // Non-stack/non-bomb status effects
            ['defense', 'rage', 'poison', 'slow', 'regen', 'wait', 'stun', 'immunity', 'blind', 'mortal_contract'].forEach(key => {
                const value = player.status[key];
                if (value > 0) {
                    let text = getStatusName(key);
                    let displayValue = '';
                    if (key === 'defense') displayValue = ` (+${value})`;
                    else if (key !== 'crit_focus' && key !== 'wait') displayValue = ` (${value}í„´)`;
                    
                    statusText.push(`<span class="text-pink-300">${text}${displayValue}</span>`);
                }
            });
            
            // Stackable status effects
            if (player.status.defense_stack > 0) statusText.push(`<span class="text-blue-300">ê°•í™” ë°©íŒ¨ (x${player.status.defense_stack})</span>`);
            if (player.status.poison_stack > 0) statusText.push(`<span class="text-purple-300">ëˆ„ì  ë… (x${player.status.poison_stack})</span>`);
            if (player.status.shield > 0) statusText.push(`<span class="text-blue-400">ë³´í˜¸ë§‰ (${player.status.shield}HP)</span>`);
            if (player.status.crit_focus > 0) statusText.push(`<span class="text-red-300">ì¹˜ëª…íƒ€ ì§‘ì¤‘ (1íšŒ)</span>`);
            
            // Bomb status effects
            if (player.status.statusBomb.duration > 0) statusText.push(`<span class="text-orange-300">ì§€ì—° í­íƒ„ (${player.status.statusBomb.duration}í„´)</span>`);


            // Revive Flag
            if (player.canRevive) statusText.push(`<span class="text-green-500">ë¶€í™œ ì¤€ë¹„ (1íšŒ)</span>`);


            statusEl.innerHTML = statusText.length > 0 ? statusText.join(', ') : 'ì—†ìŒ';

            if (isActive && !gameState.isGameOver && !isGamePending) {
                card.classList.add('current-turn-glow');
            } else {
                card.classList.remove('current-turn-glow');
            }
        }

        function renderSkills(skills, currentEnergy, isLocked, isUnderContract) {
            const container = document.getElementById('skill-buttons');
            container.innerHTML = ''; 
            const activePlayer = getActivePlayer();

            skills.forEach(skill => {
                const button = document.createElement('button');
                
                // Calculate Cost for display
                let displayCost = skill.cost;
                let isHPCost = false;
                let actualEnergyCost = 0;
                let hpCost = 0;

                if (skill.cost === 'HP(20%)') {
                    isHPCost = true;
                    hpCost = Math.ceil(activePlayer.currentHp * 0.2);
                    displayCost = `â¤ï¸ ${hpCost} HP`;
                } else {
                    actualEnergyCost = skill.cost;
                    if (skill.effect === 'extra_turn' && activePlayer.status.extraTurnUsed) {
                        actualEnergyCost = 100;
                        displayCost = 'âš¡ 100 E';
                    } else {
                        displayCost = `âš¡ ${actualEnergyCost} E`;
                    }
                }

                // Additional Contract Restriction: If under contract, only utility/defend/heal allowed.
                const isContractBlocked = isUnderContract && (skill.type === 'attack' || skill.cost === 'HP(20%)');
                
                const isDisabled = isLocked || isContractBlocked || (isHPCost ? activePlayer.currentHp <= hpCost : actualEnergyCost > currentEnergy); 
                
                button.className = `skill-button p-3 rounded-lg text-center font-semibold text-white transition duration-200 shadow-md ${isDisabled ? 'bg-gray-700' : 'bg-blue-600 hover:bg-blue-700'}`;
                button.disabled = isDisabled;
                button.onclick = () => handleSkillUse(skill);
                
                let nameText = skill.name;
                if (isContractBlocked) {
                    nameText += ' (ê³„ì•½ ê¸ˆì§€)';
                }

                button.innerHTML = `
                    <p class="text-lg">${nameText}</p>
                    <p class="text-xs mt-1 text-yellow-300">${displayCost}</p>
                    <p class="text-xs text-gray-300">${skill.desc}</p>
                `;
                container.appendChild(button);
            });
        }

        function logMessage(message, colorClass = 'text-gray-300') {
            const p = document.createElement('p');
            p.className = colorClass;
            p.textContent = `[í„´ ${gameState.turnCount}] ${message}`;
            logOutput.prepend(p);
            
            while (logOutput.children.length > 50) {
                logOutput.removeChild(logOutput.lastChild);
            }
        }

        function showModal() {
            document.getElementById('game-over-modal').classList.remove('hidden');
            document.getElementById('game-over-modal').classList.add('flex');
        }

        function hideModal() {
            document.getElementById('game-over-modal').classList.add('hidden');
            document.getElementById('game-over-modal').classList.remove('flex');
        }

        // Initialize the app to the setup screen
        window.onload = function() {
            showSetupScreen();
        };

    </script>
</body>
</html>